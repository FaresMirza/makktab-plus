generator client {
  provider = "prisma-client"
  output="src/generated/prisma-client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}



model Office {
  id          Int          @id @default(autoincrement())
  publicId    String       @unique @default(uuid())
  name        String
  ownerUserId Int          @unique
  status      OfficeStatus
  createdAt   DateTime     @default(now())

  owner            User              @relation("OfficeOwner", fields: [ownerUserId], references: [id])
  users            User[]
  projects         Project[]
  otpCodes         OtpCode[]

  projectAuditLogs ProjectAuditLog[]
  taskAuditLogs    TaskAuditLog[]
}

model OfficeRequest {
  id           String   @id @default(uuid())
  officeName   String
  fullName     String
  email        String
  phone        String
  username     String
  passwordHash String
  status       Boolean?
  createdAt    DateTime @default(now())
}

model User {
  id                 Int        @id @default(autoincrement())
  publicId           String     @unique @default(uuid())
  fullName           String
  email              String
  phone              String
  username           String     @unique
  passwordHash       String
  refreshTokenHash   String?
  lastPasswordChange DateTime?
  roles              String[]
  status             UserStatus
  lockedUntil        DateTime?
  createdAt          DateTime   @default(now())
  updatedAt          DateTime   @updatedAt

  offices          Office[]
  ownedOffice      Office?           @relation("OfficeOwner")
  createdProjects  Project[]         @relation("CreatedProjects")
  managedProjects  Project[]         @relation("ManagedProjects")
  createdTasks     Task[]            @relation("CreatedTasks")
  assignedTasks    Task[]            @relation("AssignedTasks")
  otpCodes         OtpCode[]


  authAuditLogs    AuthAuditLog[]
  projectAuditLogs ProjectAuditLog[]
  taskAuditLogs    TaskAuditLog[]
}

model Role {
  id          Int      @id @default(autoincrement())
  publicId    String   @unique @default(uuid())
  key         String   @unique
  scope       String
  name        String
  description String?
  createdAt   DateTime @default(now())
}

model Project {
  id                   Int           @id @default(autoincrement())
  publicId             String        @unique @default(uuid())
  officeId             Int
  createdByUserId      Int
  projectManagerUserId Int
  name                 String
  description          String?
  status               ProjectStatus
  createdAt            DateTime      @default(now())

  office         Office            @relation(fields: [officeId], references: [id])
  createdBy      User              @relation("CreatedProjects", fields: [createdByUserId], references: [id])
  projectManager User              @relation("ManagedProjects", fields: [projectManagerUserId], references: [id])
  tasks          Task[]
  auditLogs      ProjectAuditLog[]
}

model Task {
  id               Int        @id @default(autoincrement())
  publicId         String     @unique @default(uuid())
  projectId        Int
  createdByUserId  Int
  assignedToUserId Int
  title            String
  description      String?
  status           TaskStatus
  dueDate          DateTime?
  createdAt        DateTime   @default(now())

  project    Project        @relation(fields: [projectId], references: [id])
  createdBy  User           @relation("CreatedTasks", fields: [createdByUserId], references: [id])
  assignedTo User           @relation("AssignedTasks", fields: [assignedToUserId], references: [id])
  auditLogs  TaskAuditLog[]
}

model OtpCode {
  id                Int        @id @default(autoincrement())
  userId            Int
  officeId          Int
  email             String
  purpose           OtpPurpose
  channel           OtpChannel
  codeHash          String
  attempts          Int        @default(0)
  maxAttempts       Int        @default(3)
  status            OtpStatus  @default(PENDING)
  deviceFingerprint String?
  ip                String?
  userAgent         String?
  emailSnapshot     String?
  phoneSnapshot     String?
  expiresAt         DateTime
  usedAt            DateTime?
  createdAt         DateTime   @default(now())

  user   User   @relation(fields: [userId], references: [id])
  office Office @relation(fields: [officeId], references: [id])
}



model ProjectAuditLog {
  id                Int           @id @default(autoincrement())
  officeId          Int
  projectId         Int
  actorUserId       Int
  action            ProjectAction
  fieldName         String?
  oldValue          String?
  newValue          String?
  ip                String?
  deviceFingerprint String?
  geo               String?
  createdAt         DateTime      @default(now())

  office  Office  @relation(fields: [officeId], references: [id])
  project Project @relation(fields: [projectId], references: [id])
  actor   User    @relation(fields: [actorUserId], references: [id])
}

model TaskAuditLog {
  id                Int        @id @default(autoincrement())
  officeId          Int
  taskId            Int
  actorUserId       Int
  action            TaskAction
  fieldName         String?
  oldValue          String?
  newValue          String?
  ip                String?
  deviceFingerprint String?
  geo               String?
  createdAt         DateTime   @default(now())

  office Office @relation(fields: [officeId], references: [id])
  task   Task   @relation(fields: [taskId], references: [id])
  actor  User   @relation(fields: [actorUserId], references: [id])
}

enum OfficeStatus {
  ACTIVE
  SUSPENDED
}

enum UserStatus {
  PENDING
  ACTIVE
  LOCKED
  SUSPENDED
  DEACTIVATED
}

enum ProjectStatus {
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum TaskStatus {
  TODO
  IN_PROGRESS
  DONE
  CANCELLED
}

enum OtpPurpose {
  FIRST_LOGIN
  LOGIN
  RESET_PASSWORD
  CHANGE_DETAILS
}

enum OtpChannel {
  SMS
  EMAIL
}

enum OtpStatus {
  PENDING
  VERIFIED
  EXPIRED
  BLOCKED
}



enum ProjectAction {
  CREATE
  UPDATE
  DELETE
  STATUS_CHANGE
}

enum TaskAction {
  CREATE
  UPDATE
  DELETE
  STATUS_CHANGE
  ASSIGN
  DUE_DATE_CHANGE
}

enum AuthAuditEvent {
  INVALID_CREDENTIALS
  INVALID_OTP
  OTP_MAX_ATTEMPTS
  RATE_LIMIT_EXCEEDED
  BLOCKED_ACCESS
  ACCOUNT_LOCKED
  LOGIN_SUCCESS
  PASSWORD_RESET
  PASSWORD_CHANGED
  TOKEN_REVOKED
}

model AuthAuditLog {
  id                Int            @id @default(autoincrement())
  userId            Int?
  event             AuthAuditEvent
  reason            String?
  ip                String?
  deviceFingerprint String?
  country           String?
  userAgent         String?
  createdAt         DateTime       @default(now())

  user User? @relation(fields: [userId], references: [id])
}
